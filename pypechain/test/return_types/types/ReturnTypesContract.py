"""A web3.py Contract class for the ReturnTypes contract.

DO NOT EDIT.  This file was generated by pypechain.  See documentation at
https://github.com/delvtech/pypechain"""

# contracts have PascalCase names
# pylint: disable=invalid-name

# contracts control how many attributes and arguments we have in generated code
# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-arguments

# we don't need else statement if the other conditionals all have return,
# but it's easier to generate
# pylint: disable=no-else-return

# This file is bound to get very long depending on contract sizes.
# pylint: disable=too-many-lines

from __future__ import annotations

from dataclasses import fields, is_dataclass
from typing import Any, Tuple, Type, TypeVar, cast

from eth_typing import ChecksumAddress, HexStr
from hexbytes import HexBytes

from typing_extensions import Self
from web3 import Web3
from web3.contract.contract import Contract, ContractFunction, ContractFunctions
from web3.exceptions import FallbackNotFound
from web3.types import ABI, BlockIdentifier, CallOverride, TxParams
from .ReturnTypesTypes import SimpleStruct, InnerStruct, NestedStruct

T = TypeVar("T")

structs = {
    "SimpleStruct": SimpleStruct,
    "InnerStruct": InnerStruct,
    "NestedStruct": NestedStruct,
}


def tuple_to_dataclass(cls: type[T], tuple_data: Any | Tuple[Any, ...]) -> T:
    """
    Converts a tuple (including nested tuples) to a dataclass instance.  If cls is not a dataclass,
    then the data will just be passed through this function.

    Arguments
    ---------
    cls: type[T]
        The dataclass type to which the tuple data is to be converted.
    tuple_data: Any | Tuple[Any, ...]
        A tuple (or nested tuple) of values to convert into a dataclass instance.

    Returns
    -------
    T
        Either an instance of cls populated with data from tuple_data or tuple_data itself.
    """
    if not is_dataclass(cls):
        return cast(T, tuple_data)

    field_types = {field.name: field.type for field in fields(cls)}
    field_values = {}

    for (field_name, field_type), value in zip(field_types.items(), tuple_data):
        field_type = structs.get(field_type, field_type)
        if is_dataclass(field_type):
            # Recursively convert nested tuples to nested dataclasses
            field_values[field_name] = tuple_to_dataclass(field_type, value)
        elif (
            isinstance(value, tuple)
            and not getattr(field_type, "_name", None) == "Tuple"
        ):
            # If it's a tuple and the field is not intended to be a tuple, assume it's a nested dataclass
            field_values[field_name] = tuple_to_dataclass(field_type, value)
        else:
            # Otherwise, set the primitive value directly
            field_values[field_name] = value

    return cls(**field_values)


class ReturnTypesMixStructsAndPrimitivesContractFunction(ContractFunction):
    """ContractFunction for the mixStructsAndPrimitives method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(self) -> "ReturnTypesMixStructsAndPrimitivesContractFunction":
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> tuple[SimpleStruct, NestedStruct, int, str, bool]:
        """returns (SimpleStruct, NestedStruct, int, str, bool)"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = [SimpleStruct, NestedStruct, int, str, bool]

        return cast(
            tuple[SimpleStruct, NestedStruct, int, str, bool],
            self._call(return_types, raw_values),
        )

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesMixedTwoValuesContractFunction(ContractFunction):
    """ContractFunction for the mixedTwoValues method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(
        self, x: int, y: int
    ) -> "ReturnTypesMixedTwoValuesContractFunction":
        clone = super().__call__(x, y)
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> tuple[int, int]:
        """returns (int, int)"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = [int, int]

        return cast(tuple[int, int], self._call(return_types, raw_values))

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesNamedSingleStructContractFunction(ContractFunction):
    """ContractFunction for the namedSingleStruct method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(self) -> "ReturnTypesNamedSingleStructContractFunction":
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> SimpleStruct:
        """returns SimpleStruct"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = SimpleStruct

        return cast(SimpleStruct, self._call(return_types, raw_values))

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesNamedSingleValueContractFunction(ContractFunction):
    """ContractFunction for the namedSingleValue method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(
        self, x: int, y: int
    ) -> "ReturnTypesNamedSingleValueContractFunction":
        clone = super().__call__(x, y)
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = int

        return cast(int, self._call(return_types, raw_values))

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesNamedTwoMixedStructsContractFunction(ContractFunction):
    """ContractFunction for the namedTwoMixedStructs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(self) -> "ReturnTypesNamedTwoMixedStructsContractFunction":
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> tuple[SimpleStruct, NestedStruct]:
        """returns (SimpleStruct, NestedStruct)"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = [SimpleStruct, NestedStruct]

        return cast(
            tuple[SimpleStruct, NestedStruct],
            self._call(return_types, raw_values),
        )

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesNamedTwoValuesContractFunction(ContractFunction):
    """ContractFunction for the namedTwoValues method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(
        self, x: int, y: int
    ) -> "ReturnTypesNamedTwoValuesContractFunction":
        clone = super().__call__(x, y)
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> tuple[int, int]:
        """returns (int, int)"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = [int, int]

        return cast(tuple[int, int], self._call(return_types, raw_values))

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesNoNameSingleValueContractFunction(ContractFunction):
    """ContractFunction for the noNameSingleValue method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(
        self, x: int
    ) -> "ReturnTypesNoNameSingleValueContractFunction":
        clone = super().__call__(x)
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> int:
        """returns int"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = int

        return cast(int, self._call(return_types, raw_values))

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesNoNameTwoValuesContractFunction(ContractFunction):
    """ContractFunction for the noNameTwoValues method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(self, s: str) -> "ReturnTypesNoNameTwoValuesContractFunction":
        clone = super().__call__(s)
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> tuple[str, int]:
        """returns (str, int)"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = [str, int]

        return cast(tuple[str, int], self._call(return_types, raw_values))

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesSingleNestedStructContractFunction(ContractFunction):
    """ContractFunction for the singleNestedStruct method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(self) -> "ReturnTypesSingleNestedStructContractFunction":
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> NestedStruct:
        """returns NestedStruct"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = NestedStruct

        return cast(NestedStruct, self._call(return_types, raw_values))

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesSingleSimpleStructContractFunction(ContractFunction):
    """ContractFunction for the singleSimpleStruct method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(self) -> "ReturnTypesSingleSimpleStructContractFunction":
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> SimpleStruct:
        """returns SimpleStruct"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = SimpleStruct

        return cast(SimpleStruct, self._call(return_types, raw_values))

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesTwoMixedStructsContractFunction(ContractFunction):
    """ContractFunction for the twoMixedStructs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(self) -> "ReturnTypesTwoMixedStructsContractFunction":
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> tuple[SimpleStruct, NestedStruct]:
        """returns (SimpleStruct, NestedStruct)"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = [SimpleStruct, NestedStruct]

        return cast(
            tuple[SimpleStruct, NestedStruct],
            self._call(return_types, raw_values),
        )

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesTwoSimpleStructsContractFunction(ContractFunction):
    """ContractFunction for the twoSimpleStructs method."""

    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ

    def __call__(self) -> "ReturnTypesTwoSimpleStructsContractFunction":
        clone = super().__call__()
        self.kwargs = clone.kwargs
        self.args = clone.args
        return self

    def call(
        self,
        transaction: TxParams | None = None,
        block_identifier: BlockIdentifier = "latest",
        state_override: CallOverride | None = None,
        ccip_read_enabled: bool | None = None,
    ) -> tuple[SimpleStruct, SimpleStruct]:
        """returns (SimpleStruct, SimpleStruct)"""
        raw_values = super().call(
            transaction, block_identifier, state_override, ccip_read_enabled
        )
        # Define the expected return types from the smart contract call
        return_types = [SimpleStruct, SimpleStruct]

        return cast(
            tuple[SimpleStruct, SimpleStruct],
            self._call(return_types, raw_values),
        )

    def _call(self, return_types, raw_values):
        # cover case of multiple return values
        if isinstance(return_types, list):
            # Ensure raw_values is a tuple for consistency
            if not isinstance(raw_values, list):
                raw_values = (raw_values,)

            # Convert the tuple to the dataclass instance using the utility function
            converted_values = tuple(
                (
                    tuple_to_dataclass(return_type, value)
                    for return_type, value in zip(return_types, raw_values)
                )
            )

            return converted_values

        # cover case of single return value
        converted_value = tuple_to_dataclass(return_types, raw_values)
        return converted_value


class ReturnTypesContractFunctions(ContractFunctions):
    """ContractFunctions for the ReturnTypes contract."""

    mixStructsAndPrimitives: ReturnTypesMixStructsAndPrimitivesContractFunction

    mixedTwoValues: ReturnTypesMixedTwoValuesContractFunction

    namedSingleStruct: ReturnTypesNamedSingleStructContractFunction

    namedSingleValue: ReturnTypesNamedSingleValueContractFunction

    namedTwoMixedStructs: ReturnTypesNamedTwoMixedStructsContractFunction

    namedTwoValues: ReturnTypesNamedTwoValuesContractFunction

    noNameSingleValue: ReturnTypesNoNameSingleValueContractFunction

    noNameTwoValues: ReturnTypesNoNameTwoValuesContractFunction

    singleNestedStruct: ReturnTypesSingleNestedStructContractFunction

    singleSimpleStruct: ReturnTypesSingleSimpleStructContractFunction

    twoMixedStructs: ReturnTypesTwoMixedStructsContractFunction

    twoSimpleStructs: ReturnTypesTwoSimpleStructsContractFunction

    def __init__(
        self,
        abi: ABI,
        w3: "Web3",
        address: ChecksumAddress | None = None,
        decode_tuples: bool | None = False,
    ) -> None:
        super().__init__(abi, w3, address, decode_tuples)
        self.mixStructsAndPrimitives = (
            ReturnTypesMixStructsAndPrimitivesContractFunction.factory(
                "mixStructsAndPrimitives",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="mixStructsAndPrimitives",
            )
        )
        self.mixedTwoValues = ReturnTypesMixedTwoValuesContractFunction.factory(
            "mixedTwoValues",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="mixedTwoValues",
        )
        self.namedSingleStruct = (
            ReturnTypesNamedSingleStructContractFunction.factory(
                "namedSingleStruct",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="namedSingleStruct",
            )
        )
        self.namedSingleValue = (
            ReturnTypesNamedSingleValueContractFunction.factory(
                "namedSingleValue",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="namedSingleValue",
            )
        )
        self.namedTwoMixedStructs = (
            ReturnTypesNamedTwoMixedStructsContractFunction.factory(
                "namedTwoMixedStructs",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="namedTwoMixedStructs",
            )
        )
        self.namedTwoValues = ReturnTypesNamedTwoValuesContractFunction.factory(
            "namedTwoValues",
            w3=w3,
            contract_abi=abi,
            address=address,
            decode_tuples=decode_tuples,
            function_identifier="namedTwoValues",
        )
        self.noNameSingleValue = (
            ReturnTypesNoNameSingleValueContractFunction.factory(
                "noNameSingleValue",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="noNameSingleValue",
            )
        )
        self.noNameTwoValues = (
            ReturnTypesNoNameTwoValuesContractFunction.factory(
                "noNameTwoValues",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="noNameTwoValues",
            )
        )
        self.singleNestedStruct = (
            ReturnTypesSingleNestedStructContractFunction.factory(
                "singleNestedStruct",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="singleNestedStruct",
            )
        )
        self.singleSimpleStruct = (
            ReturnTypesSingleSimpleStructContractFunction.factory(
                "singleSimpleStruct",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="singleSimpleStruct",
            )
        )
        self.twoMixedStructs = (
            ReturnTypesTwoMixedStructsContractFunction.factory(
                "twoMixedStructs",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="twoMixedStructs",
            )
        )
        self.twoSimpleStructs = (
            ReturnTypesTwoSimpleStructsContractFunction.factory(
                "twoSimpleStructs",
                w3=w3,
                contract_abi=abi,
                address=address,
                decode_tuples=decode_tuples,
                function_identifier="twoSimpleStructs",
            )
        )


returntypes_abi: ABI = cast(
    ABI,
    [
        {
            "inputs": [],
            "name": "mixStructsAndPrimitives",
            "outputs": [
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                    ],
                    "internalType": "struct ReturnTypes.SimpleStruct",
                    "name": "simpleStruct",
                    "type": "tuple",
                },
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                        {
                            "components": [
                                {
                                    "internalType": "bool",
                                    "name": "boolVal",
                                    "type": "bool",
                                }
                            ],
                            "internalType": "struct ReturnTypes.InnerStruct",
                            "name": "innerStruct",
                            "type": "tuple",
                        },
                    ],
                    "internalType": "struct ReturnTypes.NestedStruct",
                    "name": "",
                    "type": "tuple",
                },
                {"internalType": "uint256", "name": "", "type": "uint256"},
                {"internalType": "string", "name": "name", "type": "string"},
                {"internalType": "bool", "name": "YesOrNo", "type": "bool"},
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "uint256", "name": "x", "type": "uint256"},
                {"internalType": "uint256", "name": "y", "type": "uint256"},
            ],
            "name": "mixedTwoValues",
            "outputs": [
                {"internalType": "uint256", "name": "flip", "type": "uint256"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "namedSingleStruct",
            "outputs": [
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                    ],
                    "internalType": "struct ReturnTypes.SimpleStruct",
                    "name": "struct1",
                    "type": "tuple",
                }
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "uint256", "name": "x", "type": "uint256"},
                {"internalType": "uint256", "name": "y", "type": "uint256"},
            ],
            "name": "namedSingleValue",
            "outputs": [
                {"internalType": "uint256", "name": "added", "type": "uint256"}
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "namedTwoMixedStructs",
            "outputs": [
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                    ],
                    "internalType": "struct ReturnTypes.SimpleStruct",
                    "name": "simpleStruct",
                    "type": "tuple",
                },
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                        {
                            "components": [
                                {
                                    "internalType": "bool",
                                    "name": "boolVal",
                                    "type": "bool",
                                }
                            ],
                            "internalType": "struct ReturnTypes.InnerStruct",
                            "name": "innerStruct",
                            "type": "tuple",
                        },
                    ],
                    "internalType": "struct ReturnTypes.NestedStruct",
                    "name": "nestedStruct",
                    "type": "tuple",
                },
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "uint256", "name": "x", "type": "uint256"},
                {"internalType": "uint256", "name": "y", "type": "uint256"},
            ],
            "name": "namedTwoValues",
            "outputs": [
                {"internalType": "uint256", "name": "flip", "type": "uint256"},
                {"internalType": "uint256", "name": "flop", "type": "uint256"},
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "uint256", "name": "x", "type": "uint256"}
            ],
            "name": "noNameSingleValue",
            "outputs": [
                {"internalType": "uint256", "name": "", "type": "uint256"}
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [
                {"internalType": "string", "name": "s", "type": "string"}
            ],
            "name": "noNameTwoValues",
            "outputs": [
                {"internalType": "string", "name": "", "type": "string"},
                {"internalType": "uint256", "name": "", "type": "uint256"},
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "singleNestedStruct",
            "outputs": [
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                        {
                            "components": [
                                {
                                    "internalType": "bool",
                                    "name": "boolVal",
                                    "type": "bool",
                                }
                            ],
                            "internalType": "struct ReturnTypes.InnerStruct",
                            "name": "innerStruct",
                            "type": "tuple",
                        },
                    ],
                    "internalType": "struct ReturnTypes.NestedStruct",
                    "name": "",
                    "type": "tuple",
                }
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "singleSimpleStruct",
            "outputs": [
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                    ],
                    "internalType": "struct ReturnTypes.SimpleStruct",
                    "name": "",
                    "type": "tuple",
                }
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "twoMixedStructs",
            "outputs": [
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                    ],
                    "internalType": "struct ReturnTypes.SimpleStruct",
                    "name": "",
                    "type": "tuple",
                },
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                        {
                            "components": [
                                {
                                    "internalType": "bool",
                                    "name": "boolVal",
                                    "type": "bool",
                                }
                            ],
                            "internalType": "struct ReturnTypes.InnerStruct",
                            "name": "innerStruct",
                            "type": "tuple",
                        },
                    ],
                    "internalType": "struct ReturnTypes.NestedStruct",
                    "name": "",
                    "type": "tuple",
                },
            ],
            "stateMutability": "pure",
            "type": "function",
        },
        {
            "inputs": [],
            "name": "twoSimpleStructs",
            "outputs": [
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                    ],
                    "internalType": "struct ReturnTypes.SimpleStruct",
                    "name": "",
                    "type": "tuple",
                },
                {
                    "components": [
                        {
                            "internalType": "uint256",
                            "name": "intVal",
                            "type": "uint256",
                        },
                        {
                            "internalType": "string",
                            "name": "strVal",
                            "type": "string",
                        },
                    ],
                    "internalType": "struct ReturnTypes.SimpleStruct",
                    "name": "",
                    "type": "tuple",
                },
            ],
            "stateMutability": "pure",
            "type": "function",
        },
    ],
)
# pylint: disable=line-too-long
returntypes_bytecode = HexStr(
    "0x608060405234801561000f575f80fd5b50610d8d8061001d5f395ff3fe608060405234801561000f575f80fd5b50600436106100b2575f3560e01c806380a4d0601161006f57806380a4d06014610194578063811d9aa3146101c5578063879896af146101e3578063c567c2f314610214578063d6c1a03e14610232578063e0f7c60414610263576100b2565b8063389e9102146100b657806340e27b10146100e657806353fd1043146101055780636456bc7914610124578063730fe90e1461014257806373b10c0f14610172575b5f80fd5b6100d060048036038101906100cb91906107e3565b610282565b6040516100dd919061081d565b60405180910390f35b6100ee61028b565b6040516100fc929190610909565b60405180910390f35b61010d610343565b60405161011b9291906109bf565b60405180910390f35b61012c610412565b60405161013991906109f4565b60405180910390f35b61015c60048036038101906101579190610a14565b61046a565b604051610169919061081d565b60405180910390f35b61017a61047f565b60405161018b959493929190610aa9565b60405180910390f35b6101ae60048036038101906101a99190610a14565b610593565b6040516101bc929190610b0f565b60405180910390f35b6101cd6105a2565b6040516101da91906109f4565b60405180910390f35b6101fd60048036038101906101f89190610c62565b6105fa565b60405161020b929190610ca9565b60405180910390f35b61021c610609565b6040516102299190610cd7565b60405180910390f35b61024c60048036038101906102479190610a14565b610678565b60405161025a929190610b0f565b60405180910390f35b61026b610687565b6040516102799291906109bf565b60405180910390f35b5f819050919050565b61029361074c565b61029b61074c565b5f6040518060400160405280600181526020016040518060400160405280601081526020017f596f7520617265206e756d62657220310000000000000000000000000000000081525081525090505f6040518060400160405280600281526020016040518060400160405280601081526020017f596f7520617265206e756d626572203200000000000000000000000000000000815250815250905081819350935050509091565b61034b61074c565b610353610765565b5f6040518060400160405280600181526020016040518060400160405280601081526020017f596f7520617265206e756d62657220310000000000000000000000000000000081525081525090505f6040518060600160405280600281526020016040518060400160405280601081526020017f596f7520617265206e756d6265722032000000000000000000000000000000008152508152602001604051806020016040528060011515815250815250905081819350935050509091565b61041a61074c565b6040518060400160405280600181526020016040518060400160405280601081526020017f596f7520617265206e756d626572203100000000000000000000000000000000815250815250905090565b5f81836104779190610d24565b905092915050565b61048761074c565b61048f610765565b5f60605f6040518060400160405280600181526020016040518060400160405280601081526020017f596f7520617265206e756d62657220310000000000000000000000000000000081525081525094505f6040518060600160405280600281526020016040518060400160405280601081526020017f596f7520617265206e756d62657220320000000000000000000000000000000081525081526020016040518060200160405280600115158152508152509050858160015f6040518060400160405280601381526020017f52657475726e5479706573436f6e7472616374000000000000000000000000008152509095509550955095509550509091929394565b5f808284915091509250929050565b6105aa61074c565b6040518060400160405280600181526020016040518060400160405280601081526020017f596f7520617265206e756d626572203100000000000000000000000000000000815250815250905090565b60605f82600291509150915091565b610611610765565b6040518060600160405280600181526020016040518060400160405280601081526020017f596f7520617265206e756d6265722031000000000000000000000000000000008152508152602001604051806020016040528060011515815250815250905090565b5f808284915091509250929050565b61068f61074c565b610697610765565b6040518060400160405280600181526020016040518060400160405280601081526020017f596f7520617265206e756d62657220310000000000000000000000000000000081525081525091506040518060600160405280600281526020016040518060400160405280601081526020017f596f7520617265206e756d626572203200000000000000000000000000000000815250815260200160405180602001604052806001151581525081525090509091565b60405180604001604052805f8152602001606081525090565b60405180606001604052805f81526020016060815260200161078561078b565b81525090565b60405180602001604052805f151581525090565b5f604051905090565b5f80fd5b5f80fd5b5f819050919050565b6107c2816107b0565b81146107cc575f80fd5b50565b5f813590506107dd816107b9565b92915050565b5f602082840312156107f8576107f76107a8565b5b5f610805848285016107cf565b91505092915050565b610817816107b0565b82525050565b5f6020820190506108305f83018461080e565b92915050565b61083f816107b0565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f5b8381101561087c578082015181840152602081019050610861565b5f8484015250505050565b5f601f19601f8301169050919050565b5f6108a182610845565b6108ab818561084f565b93506108bb81856020860161085f565b6108c481610887565b840191505092915050565b5f604083015f8301516108e45f860182610836565b50602083015184820360208601526108fc8282610897565b9150508091505092915050565b5f6040820190508181035f83015261092181856108cf565b9050818103602083015261093581846108cf565b90509392505050565b5f8115159050919050565b6109528161093e565b82525050565b602082015f82015161096c5f850182610949565b50505050565b5f606083015f8301516109875f860182610836565b506020830151848203602086015261099f8282610897565b91505060408301516109b46040860182610958565b508091505092915050565b5f6040820190508181035f8301526109d781856108cf565b905081810360208301526109eb8184610972565b90509392505050565b5f6020820190508181035f830152610a0c81846108cf565b905092915050565b5f8060408385031215610a2a57610a296107a8565b5b5f610a37858286016107cf565b9250506020610a48858286016107cf565b9150509250929050565b5f82825260208201905092915050565b5f610a6c82610845565b610a768185610a52565b9350610a8681856020860161085f565b610a8f81610887565b840191505092915050565b610aa38161093e565b82525050565b5f60a0820190508181035f830152610ac181886108cf565b90508181036020830152610ad58187610972565b9050610ae4604083018661080e565b8181036060830152610af68185610a62565b9050610b056080830184610a9a565b9695505050505050565b5f604082019050610b225f83018561080e565b610b2f602083018461080e565b9392505050565b5f80fd5b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b610b7482610887565b810181811067ffffffffffffffff82111715610b9357610b92610b3e565b5b80604052505050565b5f610ba561079f565b9050610bb18282610b6b565b919050565b5f67ffffffffffffffff821115610bd057610bcf610b3e565b5b610bd982610887565b9050602081019050919050565b828183375f83830152505050565b5f610c06610c0184610bb6565b610b9c565b905082815260208101848484011115610c2257610c21610b3a565b5b610c2d848285610be6565b509392505050565b5f82601f830112610c4957610c48610b36565b5b8135610c59848260208601610bf4565b91505092915050565b5f60208284031215610c7757610c766107a8565b5b5f82013567ffffffffffffffff811115610c9457610c936107ac565b5b610ca084828501610c35565b91505092915050565b5f6040820190508181035f830152610cc18185610a62565b9050610cd0602083018461080e565b9392505050565b5f6020820190508181035f830152610cef8184610972565b905092915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610d2e826107b0565b9150610d39836107b0565b9250828201905080821115610d5157610d50610cf7565b5b9291505056fea2646970667358221220ab9bfed2dd2e6b0d5f670d4030284c5a6176d3f8b1df3749af1a2079b9258d4364736f6c63430008170033"
)


class ReturnTypesContract(Contract):
    """A web3.py Contract class for the ReturnTypes contract."""

    abi: ABI = returntypes_abi
    bytecode: bytes = HexBytes(returntypes_bytecode)

    def __init__(self, address: ChecksumAddress | None = None) -> None:
        try:
            # Initialize parent Contract class
            super().__init__(address=address)
            self.functions = ReturnTypesContractFunctions(
                returntypes_abi, self.w3, address
            )

        except FallbackNotFound:
            print("Fallback function not found. Continuing...")

    # TODO: add events
    # events: ERC20ContractEvents

    functions: ReturnTypesContractFunctions

    @classmethod
    def factory(
        cls, w3: Web3, class_name: str | None = None, **kwargs: Any
    ) -> Type[Self]:
        contract = super().factory(w3, class_name, **kwargs)
        contract.functions = ReturnTypesContractFunctions(
            returntypes_abi, w3, None
        )

        return contract
