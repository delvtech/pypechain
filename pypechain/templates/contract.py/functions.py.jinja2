{# loop over all functions and create types for each #}
{%- for name, function_data in functions.items() -%}
class {{contract_name}}{{function_data.capitalized_name}}ContractFunction(ContractFunction):
    """ContractFunction for the {{function_data.name}} method."""
    # super() call methods are generic, while our version adds values & types
    # pylint: disable=arguments-differ
{%- if function_data.signature_datas|length > 1-%}
    # disable this warning when there is overloading
    # pylint: disable=function-redefined
{%- endif -%}
{% for signature_data in function_data.signature_datas %}
{% if has_overloading %}    @multimethod{% endif %}
    def __call__(self{% if signature_data.input_names_and_types %}, {{signature_data.input_names_and_types|join(', ')}}{% endif %}) -> "{{contract_name}}{{function_data.capitalized_name}}ContractFunction":{%- if has_overloading %} #type: ignore{% endif %}
        super().__call__({{signature_data.input_names|join(', ')}})
        return self
{% endfor %}
{% endfor %}
class {{contract_name}}ContractFunctions(ContractFunctions):
    """ContractFunctions for the {{contract_name}} contract."""
{% for function in functions.values() %}
    {{function.name}}: {{contract_name}}{{function.capitalized_name}}ContractFunction
{% endfor %}