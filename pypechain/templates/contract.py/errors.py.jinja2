{# loop over all errors and create types for each #}
{%- for error_info in errors -%}
class {{contract_name}}{{error_info.name}}ContractError:
    """ContractError for {{error_info.name}}."""
    # @combomethod destroys return types, so we are redefining functions as both class and instance
    # pylint: disable=function-redefined

    # 4 byte error selector
    selector: str
    # error signature, i.e. CustomError(uint256,bool)
    signature: str

    {# TODO: remove pylint disable when we add a type-hint for argument_names #}
    # pylint: disable=useless-parent-delegation
    def __init__(
        self: "{{contract_name}}{{error_info.name}}ContractError",
    ) -> None:
        self.selector = "{{error_info.selector}}"
        self.signature = "{{error_info.signature}}"

    def decode_error_data( # type: ignore
        self: "{{contract_name}}{{error_info.name}}ContractError",
        data: HexBytes,
        # TODO: get the return type here
    ) -> str:
        """Decodes error data returns from a smart contract."""
        # do the decoding
        return "data goes here."

    @classmethod
    def decode_error_data( # type: ignore
        cls: Type["{{contract_name}}{{error_info.name}}ContractError"],
        data: HexBytes,
    ) -> str:
        """Decodes error data returns from a smart contract."""
        return "data goes here."
{% endfor %}

class {{contract_name}}ContractErrors:
    """ContractErrors for the {{contract_name}} contract."""
{% for error_info in errors %}
    {{error_info.name}}: {{contract_name}}{{error_info.name}}ContractError
{% endfor %}

    def __init__(
        self,
    ) -> None:
        {% for error_info in errors -%}
        self.{{error_info.name}} = {{contract_name}}{{error_info.name}}ContractError()
        {% endfor %}